# Example: NYC Taxi Tycoon

```elixir
Mix.install([
  {:goth, "~> 1.3.0"},
  {:broadway_cloud_pub_sub, "~> 0.8.0-dev", github: "dashbitco/broadway_cloud_pub_sub"},
  {:kino_maplibre, "~> 0.1.2"}
])

alias MapLibre, as: Ml

# Defines a Goth token callback for the pipeline
defmodule TaxiTycoon.Auth do
  def token do
    with {:ok, %Goth.Token{} = token} <- Goth.fetch(TaxiTycoon.Goth) do
      {:ok, token.token}
    end
  end
end

:ok
```

## TL;DR

In this example you learn how to process streaming data with BroadwayCloudPubSub.
The public emulated data stream is based on the
[NYC Taxi & Limousine Commission's open dataset](https://data.cityofnewyork.us/)
expanded with additional routing information using the
[Google Maps Direction API](https://developers.google.com/maps/documentation/directions/)
and interpolated timestamps to simulate a real time scenario.

## Public PubSub Data Stream

In this tutorial you will need to use the `gcloud` command-line tool
to create a Google Cloud project and a PubSub subscription to a
public topic provided for Google Codelabs.

To install `gcloud` follow the [documentation](https://cloud.google.com/sdk/gcloud/). If you are
on macOS you may consider installing it with Homebrew:

```
$ brew install --cask google-cloud-sdk
```

Now, authenticate the CLI. The fastest way to get started is to login with your own credentials:

```
$ gcloud auth application-default login
```

Then, create a new project (you can skip this step if you already have a project):

```
$ gcloud projects create <your-project-id>
```

...and create a new subscription to the public topic `projects/pubsub-public-data/topics/taxirides-realtime`:

```
$ gcloud pubsub subscriptions create taxi-test-sub --project <your-project-id> --topic projects/pubsub-public-data/topics/taxirides-realtime
Created subscription [projects/my-pubsub/subscriptions/taxi-test-sub].
```

<!-- livebook:{"break_markdown":true} -->

Before continuing, set your `project_id`:

```elixir
project_id = "<your-project-id>"
```

...and start a Goth for authentication:

```elixir
Goth.start_link(name: TaxiTycoon.Goth)
```

## Visualizer

Render a map to visualize starting locations:

```elixir
map =
  Ml.new(center: {-74.0, 40.7166638}, zoom: 8)
  |> Kino.MapLibre.add_nav_controls()
  |> Kino.MapLibre.new()
```

...and create an ETS table to track the rides by their ID:

```elixir
rides = :ets.new(:rides, [:set, :public])
```

## Pipeline

Start the Broadway pipeline to consume the PubSub subscription, then refresh the ETS table above to print the rides:

```elixir
defmodule TaxiTycoon.Pipeline do
  use Broadway

  alias Broadway.Message

  def start_link(options) do
    {project_id, options} = Keyword.pop!(options, :project_id)

    {context_options, _options} = Keyword.split(options, [:map, :rides])
    context = Map.new(context_options)

    Broadway.start_link(__MODULE__,
      name: __MODULE__,
      producer: [
        module:
          {BroadwayCloudPubSub.Producer,
           subscription: "projects/#{project_id}/subscriptions/taxi-test-sub",
           token_generator: {TaxiTycoon.Auth, :token, []}}
      ],
      processors: [
        default: []
      ],
      batchers: [
        rides: [
          batch_size: 100,
          batch_timeout: 1_000
        ],
        default: []
      ],
      context: context
    )
  end

  @impl Broadway
  def handle_message(_, %Message{} = message, %{rides: rides}) do
    message = Broadway.Message.update_data(message, &Jason.decode!/1)

    case message.data do
      %{"ride_id" => ride_id, "ride_status" => status} ->
        if status == "dropoff" do
          :ets.delete(rides, ride_id)
          # Broadway.Message.ack_immediately(message)
          message
        else
          Broadway.Message.put_batcher(message, :rides)
        end

      _ ->
        message
    end
  end

  @impl Broadway
  def handle_batch(:rides, messages, _, %{map: map, rides: rides}) do
    entries =
      for %Message{data: data} <- messages do
        {data["ride_id"], data["timestamp"], [{data["longitude"], data["latitude"]}]}
      end

    # Only add markers for entries we have not yet inserted.
    new_entry_markers =
      Enum.flat_map(entries, fn {ride_id, _timestamp, marker} ->
        case :ets.lookup(rides, ride_id) do
          [] -> [marker]
          _ -> []
        end
      end)

    Kino.MapLibre.add_markers(map, new_entry_markers)

    :ets.insert(rides, entries)

    messages
  end

  @impl Broadway
  def handle_batch(:default, messages, _, _) do
    messages
  end
end

if pid = GenServer.whereis(TaxiTycoon.Pipeline) do
  if Process.alive?(pid) do
    IO.puts("stopping the pipeline...")
    :ok = Broadway.stop(TaxiTycoon.Pipeline)
  end
end

IO.puts("starting the pipeline...")

TaxiTycoon.Pipeline.start_link(map: map, project_id: project_id, rides: rides)
```

## Teardown

When you are finished, clean up your cloud resources by deleting your subscription:

```sh
$ gcloud pubsub subscriptions delete projects/<your-project-id>/subscriptions/taxi-test-sub
```

...and deleting your project, if so desired:

```sh
$ gcloud projects delete <your-project-id>
```

## Contents of this Livebook

This example is based on the
[Dataflow Codelab](https://github.com/googlecodelabs/cloud-dataflow-nyc-taxi-tycoon)
visualizer example from the Google Codelabs GitHub repository.

*Use: The NYC Taxi & Limousine Commission's dataset is publicly available for anyone
to use under the following terms provided by the Dataset Source -
https://data.cityofnewyork.us/ - and is provided "AS IS" without any warranty, express
or implied, from Google. Google disclaims all liability for any damages, direct or
indirect, resulting from the use of the dataset.*
